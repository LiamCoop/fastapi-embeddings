// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: retrieval.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	pgvector "github.com/pgvector/pgvector-go"
)

const getChunksWithDocuments = `-- name: GetChunksWithDocuments :many
SELECT
    c.id AS chunk_id,
    c.document_version_id,
    c.sequence_number,
    c.content,
    c.metadata,
    d.id AS document_id,
    d.path AS document_path,
    d.title AS document_title,
    d.document_type AS document_type,
    d.source_metadata AS source_metadata,
    dv.version_number,
    dv.created_at AS version_created_at
FROM chunks c
JOIN document_versions dv ON c.document_version_id = dv.id
JOIN documents d ON dv.document_id = d.id
WHERE c.id = ANY($1::uuid[])
`

type GetChunksWithDocumentsRow struct {
	ChunkID           uuid.UUID       `json:"chunk_id"`
	DocumentVersionID uuid.UUID       `json:"document_version_id"`
	SequenceNumber    int32           `json:"sequence_number"`
	Content           string          `json:"content"`
	Metadata          json.RawMessage `json:"metadata"`
	DocumentID        uuid.UUID       `json:"document_id"`
	DocumentPath      string          `json:"document_path"`
	DocumentTitle     sql.NullString  `json:"document_title"`
	DocumentType      string          `json:"document_type"`
	SourceMetadata    json.RawMessage `json:"source_metadata"`
	VersionNumber     int32           `json:"version_number"`
	VersionCreatedAt  time.Time       `json:"version_created_at"`
}

func (q *Queries) GetChunksWithDocuments(ctx context.Context, chunkIds []uuid.UUID) ([]GetChunksWithDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getChunksWithDocuments, pq.Array(chunkIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChunksWithDocumentsRow
	for rows.Next() {
		var i GetChunksWithDocumentsRow
		if err := rows.Scan(
			&i.ChunkID,
			&i.DocumentVersionID,
			&i.SequenceNumber,
			&i.Content,
			&i.Metadata,
			&i.DocumentID,
			&i.DocumentPath,
			&i.DocumentTitle,
			&i.DocumentType,
			&i.SourceMetadata,
			&i.VersionNumber,
			&i.VersionCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRetrievalRequest = `-- name: InsertRetrievalRequest :one
INSERT INTO retrieval_requests (
    id,
    kb_id,
    query,
    filters,
    top_k,
    hybrid_weight,
    result_count,
    latency_ms,
    empty_result,
    created_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
RETURNING id, kb_id, query, filters, top_k, hybrid_weight, result_count, latency_ms, empty_result, created_at
`

type InsertRetrievalRequestParams struct {
	ID           uuid.UUID       `json:"id"`
	KbID         uuid.UUID       `json:"kb_id"`
	Query        string          `json:"query"`
	Filters      json.RawMessage `json:"filters"`
	TopK         int32           `json:"top_k"`
	HybridWeight float64         `json:"hybrid_weight"`
	ResultCount  int32           `json:"result_count"`
	LatencyMs    int64           `json:"latency_ms"`
	EmptyResult  bool            `json:"empty_result"`
	CreatedAt    time.Time       `json:"created_at"`
}

func (q *Queries) InsertRetrievalRequest(ctx context.Context, arg InsertRetrievalRequestParams) (RetrievalRequest, error) {
	row := q.db.QueryRowContext(ctx, insertRetrievalRequest,
		arg.ID,
		arg.KbID,
		arg.Query,
		arg.Filters,
		arg.TopK,
		arg.HybridWeight,
		arg.ResultCount,
		arg.LatencyMs,
		arg.EmptyResult,
		arg.CreatedAt,
	)
	var i RetrievalRequest
	err := row.Scan(
		&i.ID,
		&i.KbID,
		&i.Query,
		&i.Filters,
		&i.TopK,
		&i.HybridWeight,
		&i.ResultCount,
		&i.LatencyMs,
		&i.EmptyResult,
		&i.CreatedAt,
	)
	return i, err
}

const insertRetrievalResult = `-- name: InsertRetrievalResult :exec
INSERT INTO retrieval_results (
    id,
    retrieval_request_id,
    chunk_id,
    rank,
    semantic_score,
    lexical_score,
    final_score,
    created_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
`

type InsertRetrievalResultParams struct {
	ID                 uuid.UUID `json:"id"`
	RetrievalRequestID uuid.UUID `json:"retrieval_request_id"`
	ChunkID            uuid.UUID `json:"chunk_id"`
	Rank               int32     `json:"rank"`
	SemanticScore      float64   `json:"semantic_score"`
	LexicalScore       float64   `json:"lexical_score"`
	FinalScore         float64   `json:"final_score"`
	CreatedAt          time.Time `json:"created_at"`
}

func (q *Queries) InsertRetrievalResult(ctx context.Context, arg InsertRetrievalResultParams) error {
	_, err := q.db.ExecContext(ctx, insertRetrievalResult,
		arg.ID,
		arg.RetrievalRequestID,
		arg.ChunkID,
		arg.Rank,
		arg.SemanticScore,
		arg.LexicalScore,
		arg.FinalScore,
		arg.CreatedAt,
	)
	return err
}

const searchLexical = `-- name: SearchLexical :many
SELECT
    c.id AS chunk_id,
    ts_rank(to_tsvector('english', c.content), plainto_tsquery('english', $1)) AS lexical_score
FROM chunks c
JOIN document_versions dv ON c.document_version_id = dv.id
JOIN documents d ON dv.document_id = d.id
WHERE dv.is_active = true
  AND c.kb_id = $2
  AND to_tsvector('english', c.content) @@ plainto_tsquery('english', $1)
  AND ($3::text IS NULL OR d.document_type = $3)
  AND ($4::text IS NULL OR d.path LIKE $4)
  AND ($5::text IS NULL OR d.source_metadata ->> 'source' = $5)
  AND ($6::jsonb = '{}'::jsonb OR d.source_metadata @> $6::jsonb)
  AND ($7::timestamptz IS NULL OR dv.created_at >= $7)
  AND ($8::timestamptz IS NULL OR dv.created_at <= $8)
ORDER BY ts_rank(to_tsvector('english', c.content), plainto_tsquery('english', $1)) DESC
LIMIT $9
`

type SearchLexicalParams struct {
	Query         string          `json:"query"`
	KbID          uuid.UUID       `json:"kb_id"`
	DocumentType  sql.NullString  `json:"document_type"`
	PathPrefix    sql.NullString  `json:"path_prefix"`
	Source        sql.NullString  `json:"source"`
	Tags          json.RawMessage `json:"tags"`
	CreatedAfter  sql.NullTime    `json:"created_after"`
	CreatedBefore sql.NullTime    `json:"created_before"`
	Limit         int32           `json:"limit"`
}

type SearchLexicalRow struct {
	ChunkID      uuid.UUID `json:"chunk_id"`
	LexicalScore float32   `json:"lexical_score"`
}

func (q *Queries) SearchLexical(ctx context.Context, arg SearchLexicalParams) ([]SearchLexicalRow, error) {
	rows, err := q.db.QueryContext(ctx, searchLexical,
		arg.Query,
		arg.KbID,
		arg.DocumentType,
		arg.PathPrefix,
		arg.Source,
		arg.Tags,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLexicalRow
	for rows.Next() {
		var i SearchLexicalRow
		if err := rows.Scan(&i.ChunkID, &i.LexicalScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSemantic = `-- name: SearchSemantic :many
SELECT
    c.id AS chunk_id,
    CAST(1.0 - (e.embedding_vector <=> $1::vector) AS double precision) AS semantic_score
FROM chunks c
JOIN embeddings e ON c.embedding_id = e.id
JOIN document_versions dv ON c.document_version_id = dv.id
JOIN documents d ON dv.document_id = d.id
WHERE dv.is_active = true
  AND c.kb_id = $2
  AND ($3::text IS NULL OR d.document_type = $3)
  AND ($4::text IS NULL OR d.path LIKE $4)
  AND ($5::text IS NULL OR d.source_metadata ->> 'source' = $5)
  AND ($6::jsonb = '{}'::jsonb OR d.source_metadata @> $6::jsonb)
  AND ($7::timestamptz IS NULL OR dv.created_at >= $7)
  AND ($8::timestamptz IS NULL OR dv.created_at <= $8)
ORDER BY e.embedding_vector <=> $1::vector
LIMIT $9
`

type SearchSemanticParams struct {
	QueryVector   pgvector.Vector `json:"query_vector"`
	KbID          uuid.UUID       `json:"kb_id"`
	DocumentType  sql.NullString  `json:"document_type"`
	PathPrefix    sql.NullString  `json:"path_prefix"`
	Source        sql.NullString  `json:"source"`
	Tags          json.RawMessage `json:"tags"`
	CreatedAfter  sql.NullTime    `json:"created_after"`
	CreatedBefore sql.NullTime    `json:"created_before"`
	Limit         int32           `json:"limit"`
}

type SearchSemanticRow struct {
	ChunkID       uuid.UUID `json:"chunk_id"`
	SemanticScore float64   `json:"semantic_score"`
}

func (q *Queries) SearchSemantic(ctx context.Context, arg SearchSemanticParams) ([]SearchSemanticRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSemantic,
		arg.QueryVector,
		arg.KbID,
		arg.DocumentType,
		arg.PathPrefix,
		arg.Source,
		arg.Tags,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSemanticRow
	for rows.Next() {
		var i SearchSemanticRow
		if err := rows.Scan(&i.ChunkID, &i.SemanticScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRetrievalRequest = `-- name: UpdateRetrievalRequest :exec
UPDATE retrieval_requests
SET result_count = $2,
    latency_ms = $3,
    empty_result = $4
WHERE id = $1
`

type UpdateRetrievalRequestParams struct {
	ID          uuid.UUID `json:"id"`
	ResultCount int32     `json:"result_count"`
	LatencyMs   int64     `json:"latency_ms"`
	EmptyResult bool      `json:"empty_result"`
}

func (q *Queries) UpdateRetrievalRequest(ctx context.Context, arg UpdateRetrievalRequestParams) error {
	_, err := q.db.ExecContext(ctx, updateRetrievalRequest,
		arg.ID,
		arg.ResultCount,
		arg.LatencyMs,
		arg.EmptyResult,
	)
	return err
}
